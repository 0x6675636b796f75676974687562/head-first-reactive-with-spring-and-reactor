= Spring WebFlux Workshop
Brian Clozel, Violeta Georgieva - Pivotal
:sectanchors: true
:source-highlighter: prettify
:icons: font
:toc:
:spring-boot-version: 2.0.0.RC2
:spring-framework-version: 5.0.4.RELEASE
:spring-framework-doc-base: http://docs.spring.io/spring-framework/docs/{spring-framework-version}

This repository hosts a complete workshop on Spring Boot + Spring WebFlux.
Just follow this README and create your first WebFlux applications!
Each step of this workshop has its companion commit in the git history with a detailed commit message.

At the end of the workshop, we will have created three applications:

* `stock-quotes` is a functional WebFlux app which streams stock quotes
* `stock-details` is an annotation-based WebFlux app using a reactive datastore
* `trading-service` is an annotation-based WebFlux app that consumes data from `stock-quotes` and `stock-details`

Reference documentations can be useful while working on those apps:

* http://projectreactor.io/docs[Reactor Core documentation]
* Spring WebFlux
{spring-framework-doc-base}/spring-framework-reference/web.html#web-reactive[reference documentation]
and {spring-framework-doc-base}/javadoc-api/[javadoc]

We will start off by creating the Trading Service application which gets data from a pre-built Stock Quotes application.

== Trading Service application

=== Create this application

Go to `https://start.spring.io` and create a Maven project with Spring Boot {spring-boot-version},
with groupId `io.spring.workshop` and artifactId `trading-service`. Select the `Reactive Web` Boot starter.
Unzip the given file into a directory and import that application into your IDE.

Note that, by default, `spring-boot-starter-webflux` transitively brings `spring-boot-starter-reactor-netty`
and Spring Boot auto-configures Reactor Netty as a web server.

Spring Boot supports Tomcat, Undertow and Jetty as well.

=== Use the WebClient to stream JSON to the browser

In this section, we'll call our remote `stock-quotes` service to get Quotes from it, so we first need to:

* copy over the `Quote` class to this application
* add the Jackson JSR310 module dependency

Now create a `QuotesController` annotated with `@Controller` and a new method.
The method should respond to `"GET /quotes/feed"` requests with the `"text/event-stream"` content-type,
with a `Flux<Quote>` as the response body. This data is already served by the `stock-quotes` application
, so you can use a `WebClient` to request the remote web service to retrieve that `Flux`.

TIP: You should avoid making a request to the `stock-quotes` service for every browser connecting to
that page — for that, you can use the `Flux.share()` operator.

Now, let's create another application that can provide the details for a trading company.

== Stock Details application

=== Create this application

Go to `https://start.spring.io` and create a Maven project with Spring Boot {spring-boot-version},
with groupId `io.spring.workshop` and artifactId `stock-details`. Select the `Reactive Web`
and `Reactive Mongo` Boot starters.

=== Use a reactive datastore

In this application, we’ll use a MongoDB datastore with its reactive driver; for this workshop, we’ll use an in-memory instance of MongoDB. So add the following:

[source,xml]
.stock-details/pom.xml
----
include::../stock-details/pom.xml[tags=inMemMongo]
----

We'd like to manage `TradingCompany` with our datastore.

[source,java]
.stock-details/src/main/java/io/spring/workshop/stockdetails/TradingCompany.java
----
include::../stock-details/src/main/java/io/spring/workshop/stockdetails/TradingCompany.java[]
----

Now create a `TradingCompanyRepository` interface that extends `ReactiveMongoRepository`.
Add a `findByTicker(String ticker)` method that returns a single `TradingCompany` in a reactive fashion.

We'd like to insert trading companies in our datastore when the application starts up. For that, create a `TradingCompanyCommandLineRunner`
component that implements Spring Boot's `CommandLineRunner`. In the `run` method, use the reactive repository
to insert `TradingCompany` instances in the datastore.

NOTE: Since the `run` method returns void, it expects a blocking implementation. This is why you should use the
`blockLast(Duration)` operator on the `Flux` returned by the repository when inserting data.
You can also `then().block(Duration)` to turn that `Flux` into a `Mono<Void>` that waits for completion.

=== Create a JSON web service

We're now going to expose `TradingCompany` through a Controller.
First, create a `TradingCompanyController` annotated with `@RestController`.
Then add two new Controller methods in order to handle:

* GET requests to  `"/details"`, returning all `TradingCompany` instances, serializing them with content-type `"application/json"`
* GET requests to  `"/details/{ticker}"`, returning a single `TradingCompany` instance, serializing it with content-type `"application/json"`

Now that we have an application that can return the details for a company with a given ticker, we can update the Trading Service application
to use those details and return a combination of the latest quote for that ticker along with the company's details.

== Update Trading Service application

We will first create a service that will use a `WebClient` to get data from the Stock Details application.
First, create a `TradingCompanyService` annotated with `@Component`.
Then add two methods:

* `findAllCompanies` will return a `Flux<TradingCompany>` by using the webClient to get data from the `/details` endpoint from the Stock details application
* `getTradingCompany` will return a `Mono<TradingCompany>` by using the webClient to get data from the `/details/{ticker}` endpoint from the Stock details application

Since we want to combine date returned by `stock-quotes` and `stock-details`, let's create a model for that called `TradingCompanyLatestQuote`.

Copy the following classes to your project.

[source,java]
.trading-service/src/main/java/io/spring/workshop/tradingservice/TradingCompanyLatestQuote.java
----
include::../trading-service/src/main/java/io/spring/workshop/tradingservice/TradingCompanyLatestQuote.java[]
----

Now, add another method to the `QuotesController` which can handle requests to `/quotes/details/{ticker}`.

== Stock Quotes application

=== Create this application

Go to `https://start.spring.io` and create a Maven project with Spring Boot {spring-boot-version},
with groupId `io.spring.workshop` and artifactId `stock-quotes`. Select the `Reactive Web`
Boot starter.
Unzip the given file into a directory and import that application into your IDE.

If generated right, you should have a main `Application` class that looks like this:

[source,java]
.stock-quotes/src/main/java/io/spring/workshop/stockquotes/StockQuotesApplication.java
----
include::../stock-quotes/src/main/java/io/spring/workshop/stockquotes/StockQuotesApplication.java[]
----

Edit your `application.properties` file to start the server on a specific port.

[source,properties]
.stock-quotes/src/main/resources/application.properties
----
include::../stock-quotes/src/main/resources/application.properties[]
----

Launching it from your IDE or with `mvn spring-boot:run` should start a Netty server on port 8081.
You should see in the logs something like:

[source,bash]
----
INFO 2208 --- [  restartedMain] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8081
INFO 2208 --- [  restartedMain] i.s.w.s.StockQuotesApplication           : Started StockQuotesApplication in 1.905 seconds (JVM running for 3.075)
----

=== Create a Quote Generator

To simulate real stock values, we'll create a generator that emits such values at a specific interval.
Copy the following classes to your project.

[source,java]
.stock-quotes/src/main/java/io/spring/workshop/stockquotes/Quote.java
----
include::../stock-quotes/src/main/java/io/spring/workshop/stockquotes/Quote.java[]
----

[source,java]
.stock-quotes/src/main/java/io/spring/workshop/stockquotes/QuoteGenerator.java
----
include::../stock-quotes/src/main/java/io/spring/workshop/stockquotes/QuoteGenerator.java[]
----

Because we're working with `java.time.Instant` and Jackson, we should import the dedicated module in our app.

[source,xml]
.stock-quotes/pom.xml
----
include::../stock-quotes/pom.xml[tags=jacksonJSR310]
----

=== Functional web applications with "WebFlux.fn"

Spring WebFlux comes in two flavors of web applications: annotation based and functional.
For this first application, we'll use the functional variant.

Incoming HTTP requests are handled by a `HandlerFunction`, which is essentially a function
that takes a ServerRequest and returns a `Mono<ServerResponse>`. The annotation counterpart
to a handler function would be a Controller method.

But how those incoming requests are routed to the right handler?

We're using a `RouterFunction`, which is a function that takes a `ServerRequest`, and returns
a `Mono<HandlerFunction>`. If a request matches a particular route, a handler function is returned;
otherwise it returns an empty `Mono`. The `RouterFunction` has a similar purpose as the `@RequestMapping`
annotation in `@Controller` classes.

Take a look at the code samples in
{spring-framework-doc-base}/spring-framework-reference/web.html#web-reactive-server-functional[the Spring WebFlux.fn reference documentation]

=== Create your first HandlerFunction + RouterFunction

First, create a `QuoteHandler` class and mark is as a `@Component`;this class will have all our handler functions as methods.
Now create a `hello` handler function in that class that always returns "text/plain" HTTP responses with "Hello Spring!" as body.

To route requests to that handler, you need to expose a `RouterFunction` to Spring Boot.
Create a `QuoteRouter` configuration class (i.e. annotated with `@Configuration`)
that creates a bean of type `RouterFunction<ServerResponse>`.

Modify that class so that GET requests to `"/hello"` are routed to the handler you just implemented.

TIP: Since `QuoteHandler` is a component, you can inject it in `@Bean` methods as a method parameter.

Your application should now behave like this:
[source,bash]
----
$ curl http://localhost:8081/hello -i
HTTP/1.1 200 OK
transfer-encoding: chunked
Content-Type: text/plain;charset=UTF-8

Hello Spring!%
----

Once done, add another endpoint:

* with a HandlerFunction `echo` that echoes the request body in the response, as "text/plain"
* and an additional route in our existing `RouterFunction` that accepts POST requests on
`"/echo"` with a "text/plain" body and returns responses with the same content type.

You can also use this new endpoint with:

[source,bash]
----
$ curl http://localhost:8081/echo -i -d "WebFlux workshop" -H "Content-Type: text/plain"
HTTP/1.1 200 OK
transfer-encoding: chunked
Content-Type: text/plain

WebFlux workshop%
----


=== Expose the Flux<Quotes> as a web service

First, let's inject our `QuoteGenerator` instance in our `QuoteHandler`, instantiate
a `Flux<Quote>` from it that emits a `Quote` every 200 msec and can be **shared** between
multiple subscribers (look at the `Flux` operators for that). This instance should be kept
as an attribute for reusability.

Now create a `streamQuotes` handler that streams those generated quotes
with the `"application/stream+json"` content type. Add the corresponding part in the `RouterFunction`,
on the `"/quotes"` endpoint.

[source,bash]
----
$ curl http://localhost:8081/quotes -i -H "Accept: application/stream+json"
HTTP/1.1 200 OK
transfer-encoding: chunked
Content-Type: application/stream+json

{"ticker":"CTXS","price":84.0,"instant":1494841666.633000000}
{"ticker":"DELL","price":67.1,"instant":1494841666.834000000}
{"ticker":"GOOG","price":869,"instant":1494841667.034000000}
{"ticker":"MSFT","price":66.5,"instant":1494841667.231000000}
{"ticker":"ORCL","price":46.13,"instant":1494841667.433000000}
{"ticker":"RHT","price":86.9,"instant":1494841667.634000000}
{"ticker":"VMW","price":93.7,"instant":1494841667.833000000}
----


Let's now create a variant of that — instead of streaming all values (with an infinite stream), we can
now take the last "n" elements of that `Flux` and return those as a collection of Quotes with
the content type `"application/json"`. Note that you should take the requested number of Quotes
from the request itself, with the query parameter named `"size"` (or pick `10` as the default size
if none was provided).

[source,bash]
----
curl http://localhost:8081/quotes -i -H "Accept: application/json"
HTTP/1.1 200 OK
transfer-encoding: chunked
Content-Type: application/json

[{"ticker":"CTXS","price":85.8,"instant":1494842241.716000000},{"ticker":"DELL","price":64.69,"instant":1494842241.913000000},{"ticker":"GOOG","price":856.5,"instant":1494842242.112000000},{"ticker":"MSFT","price":68.2,"instant":1494842242.317000000},{"ticker":"ORCL","price":47.4,"instant":1494842242.513000000},{"ticker":"RHT","price":85.6,"instant":1494842242.716000000},{"ticker":"VMW","price":96.1,"instant":1494842242.914000000},{"ticker":"CTXS","price":85.5,"instant":1494842243.116000000},{"ticker":"DELL","price":64.88,"instant":1494842243.316000000},{"ticker":"GOOG","price":889,"instant":1494842243.517000000}]%
----


=== Integration tests with WebTestClient

Spring WebFlux (actually the `spring-test` module) includes a `WebTestClient`
that can be used to test WebFlux server endpoints with or without a running server.
Tests without a running server are comparable to MockMvc from Spring MVC where mock request
and response are used instead of connecting over the network using a socket.
The WebTestClient however can also perform tests against a running server.

You can check that your last endpoint is working properly with the following
integration test:

[source,java]
.stock-quotes/src/test/java/io/spring/workshop/stockquotes/StockQuotesApplicationTests.java
----
include::../stock-quotes/src/test/java/io/spring/workshop/stockquotes/StockQuotesApplicationTests.java[]
----

== Additional Resources

Talks on Spring Reactive:

* https://www.youtube.com/watch?v=rdgJ8fOxJhc[Reactive Web Applications with Spring 5 (Rossen Stoyanchev)]
* https://www.youtube.com/watch?v=Cj4foJzPF80[Developing Reactive applications with Reactive Streams and Java 8 (B.Clozel, S.Deleuze)]
